The feasability of Task 5:
1. If the task 5 is addressing adding philosophers randomly without adding more chopsticks (Resources), then the process is not feasible, because it will increase the possibility of starvation and extended waiting time for resources.
1.1. For instance if we have 8 philosophers with 5 chopsticks, then in order for the philosopher 7 to eat, he should check the state of the philosophers 1, 2, 3, 6 and 8.
1.2. In order to add a new philosopher, it should wait for the correct moment for entrance. That means that if his right neighbor is eating, he should be aware that he is not eating, moreover, his left neighbor is allowed to eat. Same situation will be implied regarding talking. As synchronizing that event is not an easy task, it will be preferable to add him in a moment as none of his neighbors eating.
1.3. Adding a new philosopher will change the indices of all the philosophers after him. Therefore, the state index (The chair of the philosopher) will not match the thread ID. In order to handle that challenge, the chairs of the philosophers (State Array) might be replaced by a doubly linked circular linked list, with an additional attribute for the thread ID. Despite the validity of this solution, without increasing the number of chopsticks to match the number of the philosophers, matching the chopsticks with the philosophers will be more challenging to determine the (right) and (left) chopsticks.
2. In order to remove the philosophers randomly, there is no starvation thread because that the chopsticks will be more than the philosophers. therefore conditions for eating might be relaxed because there is no possibility of having deadlocks. However, it will impose different constraints on the execution.
2.1 The monitor has to have the right to interrupt the threads manually. That is challengingly doable because the interrupt() command request termination with no guarantee of execution by the CPU
2.2. In order to remove a philosopher, it should wait for the correct moment for removal. That means that this thread finished eating and talking and at least one of his neighbors is not eating. In addition, if a chopstick will be removed with him, to ensure that nobody is using the chopstick which will be removed.
2.3. Removing a philosopher will change the indices of all the philosophers after him unless we decided to maintain an empty chair (in the state array) and the chopstick of the removed philosopher.
2.4. If we decided to remove the empty chair and the chopstick of the removed philosopher, the state index (The chair of the philosopher) will not match the thread ID. In order to handle that challenge, the chairs of the philosophers (State Array) might be replaced by a doubly linked circular linked list, with an additional attribute for the thread ID. Despite the validity of this solution, without decreasing the number of chopsticks to match the number of the philosophers, matching the chopsticks with the philosophers will be more challenging to determine the (right) and (left) chopsticks.
3. In case of replacement of Arrays by Doubly Linked Lists, that will increase the complexity of allocated memory access from O(1) to O(n).
